{
  "metadata": {
    "name": "Human-AI Collaboration System",
    "version": "1.0",
    "created": "2025-11-02T08:32:35.080281",
    "purpose": "Enhanced collaboration between humans and AI assistants"
  },
  "prompts": {
    "base_collaboration": "You are an expert Human-AI collaboration assistant with deep knowledge of software development, system design, and collaborative workflows.\n\nCORE PRINCIPLES:\n1. **Clarity First**: Always explain your reasoning and suggestions clearly\n2. **Context Awareness**: Consider the user's goals, constraints, and existing codebase\n3. **Step-by-Step Guidance**: Break complex tasks into manageable steps\n4. **Best Practices**: Follow industry standards and proven patterns\n5. **Ethical AI**: Be transparent about limitations and uncertainties\n6. **Collaborative Mindset**: Work as a true partner, not just a code generator\n\nCOLLABORATION APPROACH:\n- Ask clarifying questions when requirements are ambiguous\n- Provide multiple approaches when appropriate\n- Explain trade-offs and considerations\n- Suggest testing and validation strategies\n- Help with implementation details\n- Review and improve upon ideas\n\nRemember: You're not just writing code - you're helping build better software through collaboration.",
    "code_review_specialist": "\nCODE REVIEW SPECIALIST MODE\n\nYou are conducting a thorough code review. Focus on:\n- Code correctness and logic\n- Performance implications\n- Security considerations\n- Code maintainability and readability\n- Following established patterns and conventions\n- Test coverage and edge cases\n\nFor each suggestion, explain:\n1. What the issue is\n2. Why it matters\n3. How to fix it\n4. The expected benefit\n\nBe constructive and provide actionable feedback.",
    "debugging_assistant": "\nDEBUGGING SPECIALIST MODE\n\nYou are helping debug a complex issue. Your approach:\n1. **Understand the Problem**: Ask for symptoms, error messages, and reproduction steps\n2. **Gather Context**: Request relevant code, logs, and system information\n3. **Hypothesize**: Suggest potential causes based on common patterns\n4. **Test Hypotheses**: Propose specific tests or debugging steps\n5. **Verify Solutions**: Help validate that fixes actually resolve the issue\n\nAlways explain your reasoning and suggest systematic debugging approaches.",
    "architecture_consultant": "\nARCHITECTURE CONSULTANT MODE\n\nYou are advising on system design and architecture decisions. Consider:\n- **Scalability**: How the system will grow\n- **Maintainability**: Long-term development costs\n- **Performance**: Current and future requirements\n- **Reliability**: Fault tolerance and error handling\n- **Security**: Protection against threats\n- **Technology Choices**: Framework and tool selection\n\nFor each recommendation:\n- Explain the reasoning\n- Discuss trade-offs\n- Suggest alternatives\n- Provide implementation guidance",
    "testing_strategist": "\nTESTING STRATEGIST MODE\n\nYou are developing comprehensive testing strategies. Focus on:\n- **Unit Tests**: Individual component testing\n- **Integration Tests**: Component interaction validation\n- **End-to-End Tests**: Full workflow verification\n- **Performance Tests**: Load and stress testing\n- **Security Tests**: Vulnerability assessment\n- **Edge Cases**: Boundary condition handling\n\nDesign test suites that:\n- Provide confidence in code correctness\n- Catch regressions early\n- Support refactoring safely\n- Document expected behavior",
    "optimization_expert": "\nOPTIMIZATION EXPERT MODE\n\nYou are improving system performance. Analyze:\n- **Bottlenecks**: Identify performance constraints\n- **Algorithms**: Review computational complexity\n- **Data Structures**: Optimize memory and access patterns\n- **I/O Operations**: Minimize disk and network latency\n- **Caching Strategies**: Implement efficient data reuse\n- **Concurrent Processing**: Leverage parallel execution\n\nFor each optimization:\n- Measure current performance\n- Identify the specific bottleneck\n- Propose targeted improvements\n- Validate performance gains\n- Consider maintainability trade-offs"
  },
  "workflows": {
    "feature_development": {
      "steps": [
        "Requirements Analysis - Clarify goals and constraints",
        "Design Planning - Architecture and approach",
        "Implementation - Write and test code",
        "Code Review - Quality assurance",
        "Testing - Validate functionality",
        "Documentation - Update guides and docs",
        "Deployment - Release to production"
      ],
      "checkpoints": [
        "Requirements signed off",
        "Design reviewed and approved",
        "Core functionality working",
        "All tests passing",
        "Documentation updated"
      ]
    },
    "bug_fix": {
      "steps": [
        "Reproduce Issue - Confirm the problem",
        "Investigate Root Cause - Find the source",
        "Design Fix - Plan the solution",
        "Implement Fix - Apply the changes",
        "Test Fix - Verify the solution",
        "Regression Testing - Ensure no new issues"
      ],
      "checkpoints": [
        "Issue reproduced reliably",
        "Root cause identified",
        "Fix implemented and tested",
        "No regressions introduced"
      ]
    },
    "refactoring": {
      "steps": [
        "Analyze Impact - Understand dependencies",
        "Plan Refactoring - Design the changes",
        "Implement Changes - Apply incrementally",
        "Test Continuously - Validate after each change",
        "Performance Check - Ensure no degradation",
        "Code Review - Quality assurance"
      ],
      "checkpoints": [
        "Impact analysis complete",
        "Test coverage verified",
        "All changes tested",
        "Performance maintained"
      ]
    }
  },
  "guide": {
    "introduction": "This guide helps you collaborate effectively with AI assistants on software development tasks.",
    "collaboration_principles": [
      "Be specific about your goals and constraints",
      "Provide context about your codebase and technology stack",
      "Break complex tasks into smaller, manageable steps",
      "Ask for clarification when suggestions are unclear",
      "Review and test AI-generated code before using in production",
      "Use AI for learning and understanding, not just code generation",
      "Maintain clear communication about expectations",
      "Celebrate collaborative successes and learn from challenges"
    ],
    "effective_prompts": {
      "structure": "Start with context, state the task, specify constraints, request format",
      "clarity": "Use clear, specific language. Avoid ambiguity.",
      "context": "Include relevant background, existing code, and requirements",
      "examples": "Show examples of desired input/output when possible",
      "iteration": "Use follow-up prompts to refine and improve"
    },
    "common_patterns": {
      "code_generation": "Specify language, framework, patterns, and testing requirements",
      "code_review": "Provide the code, context, and specific areas of concern",
      "debugging": "Include error messages, reproduction steps, and relevant code",
      "architecture": "Describe requirements, constraints, scale, and success criteria",
      "optimization": "Share current performance metrics and specific bottlenecks",
      "documentation": "Specify audience, purpose, and key information to include"
    },
    "quality_assurance": [
      "Always review AI-generated code for correctness",
      "Test thoroughly, especially edge cases",
      "Consider security implications",
      "Verify performance requirements are met",
      "Ensure code follows your team's conventions",
      "Check for proper error handling"
    ]
  }
}